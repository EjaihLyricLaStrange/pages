<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>Reactive State Mutations via CQRS</title>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="stylesheet" href="/css/style.css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">

  
  <meta name="theme-color" content="#1e2327">

  
  
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@arturdryomov" />
  <meta name="twitter:title" content="Reactive State Mutations via CQRS" />
  <meta name="twitter:description" content="Managing state, the safe way. Without event sourcing (for now)." />

  
  <meta name="description" content="Managing state, the safe way. Without event sourcing (for now)." />
  

  
</head>

<body>


<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/kotlin.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-112239048-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<header>
  <nav>
    <ul>
      
      <li class="menu-left"><a href="/">Posts</a></li>
      
      
      <li class="menu-right"><a href="/index.xml">RSS</a></li>
      
      <li class="menu-right"><a href="https://twitter.com/arturdryomov">Twitter</a></li>
      
      <li class="menu-right"><a href="https://github.com/ming13">GitHub</a></li>
      
    </ul>
  </nav>
</header>

<br/>


<div class="meta">

  <h1><span class="title">Reactive State Mutations via CQRS</span></h1>
  <h3>October 21, 2018</h3>

</div>

<main>


<p>State-state-state. It surrounds us. Think hard enough and everything around
will become either a state or a state mutation.
The current time is a state and each passing second is a state mutation.
A tree can be represented by a state and each drop of rain mutates it,
increasing the water supply level and applying the pressure on leaves.</p>

<p>The concept is not new, but sometimes it becomes too hard to manage it.
Even in software development, which was basically created to represent
the world around us in strict terms.</p>

<h1 id="real-life-example">Real Life Example</h1>

<p>There is a brand-new project for book recommendations.
The very first step is getting a list of books from a backend.
This is enough <em>forever and ever</em>. Sounds good.</p>

<pre><code class="language-kotlin">interface BookService {
    fun getBooks(): Single&lt;List&lt;Book&gt;&gt;
}
</code></pre>

<p>Suddenly â€” <em>because Agile</em> â€” we need to save books on the backend.
All right.</p>

<pre><code class="language-kotlin">interface BookService {
    fun getBooks(): Single&lt;List&lt;Book&gt;&gt;
    fun createBook(book: Book): Completable
}
</code></pre>

<p>New features, new screens! Unfortunately, it means that
the books fetching progress should be preserved across screens.
A property should do the trick&hellip;</p>

<pre><code class="language-kotlin">interface BookService {
    fun getBooks(): Single&lt;List&lt;Book&gt;&gt;
    val getBooksProgress: Observable&lt;Boolean&gt;

    fun createBook(book: Book): Completable
}
</code></pre>

<p>Damn, the QA team brought up an issue at the very last minute before the release.
Fetching books might fail, and we need to show it on all screens
to give the ability to re-fetch them. Just a sec, another property
and here we go.</p>

<pre><code class="language-kotlin">interface BookService {
    fun getBooks(): Single&lt;List&lt;Book&gt;&gt;
    val getBooksProgress: Observable&lt;Boolean&gt;
    val getBooksFailure: Observable&lt;Boolean&gt;

    fun createBook(book: Book): Completable
}
</code></pre>

<p>The project hit the production! It works all right, but
the very first customer has a complaint that the book the one created has a wrong name
and there is no way to delete it. Sounds like creating a book,
but <a href="https://www.youtube.com/watch?v=2YTLtG4LMsM">some would say it is the reverse</a>&hellip;</p>

<pre><code class="language-kotlin">interface BookService {
    fun getBooks(): Single&lt;List&lt;Book&gt;&gt;
    val getBooksProgress: Observable&lt;Boolean&gt;
    val getBooksFailure: Observable&lt;Boolean&gt;

    fun createBook(book: Book): Completable
    fun deleteBook(book: Book): Completable
}
</code></pre>

<p>And then someone brings up that the <code>BookService</code> should cache books&hellip;</p>

<h1 id="this-is-bad">This is Bad</h1>

<p>The <code>BookService</code> is far from perfect.</p>

<p><code>BookService</code> clients gradually became more and more complicated.
Instead of a comfy stateless life they are forced to remember
that creating a book should trigger re-fetching books from a backend.
At the same time, this refresh operation should be done only
on <code>BookCreateResult.Success</code> and not on <code>BookCreateResult.Failure</code>.
The same goes to the delete operation.
Most likely this logic will be distributed and copy-pasted across the client code.</p>

<p>Another distinct feature is how easily the <code>BookService</code> transformed from being
stateless to be stateful. Essentially a pure <code>getBooks</code> produced
<code>getBooksProgress</code> and <code>getBooksFailure</code> side effects. It is understandable â€”
requirements have been changed, but the mistake is still there.
The change in nature hadnâ€™t been followed by the change in design.
The burden of complications was transitioned to clients.</p>

<p>Iâ€™ve spared the details of the implementation since the resulting API
is bad enough. Under the hood the <code>BookService</code> probably is juggling
multiple <code>Subject</code> or <code>Relay</code> in combination with <code>onNext</code>.
Forget about proper thread-safety â€”Â at this point it is on clients shoulders as well.
The requirement to cache data (at least in memory) will complicate things even more.</p>

<p>Do not forget that the evolution above seems to be rapid but in reality these
changes are applied gradually. Since no one has time to do a proper refactoring,
the <code>BookService</code> has a pretty good chance to stay this way forever.
Just like dinosaurs. Until the meteorite nuked them. You know how it goes.</p>

<h1 id="cqrs">CQRS</h1>

<p>Each time I think there is something smart and fresh, a careful research
reveals that the concept was there for years. CQRS is one of them.</p>

<p>CQRS stands for Command Query Responsibility Segregation.
It is a variety of CQS â€”Â Command-Query Separation.
Usually, it is connected to Event Sourcing, but it is a different story.</p>

<blockquote>
<p>ðŸ“– This article will narrow down the concept.
For further explanation I suggest reading <a href="https://martinfowler.com/bliki/CQRS.html">the Martin Fowler peace</a>
and <a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs">the Microsoft documentation</a>.</p>
</blockquote>

<p>Basically saying, CQRS replaces <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a>-like
interactions with two separate entities.</p>

<ul>
<li>Commands. Represent requests for changes of a particular resource. Serve as inputs.</li>
<li>Queries. Represent the resource. Serve as outputs.</li>
</ul>

<p>This brings a couple of benefits on the table.</p>

<ul>
<li>Performance. It becomes possible to scale resource reads and writes independently.
The most popular resource in such cases is a database.</li>
<li>Domain organization. Sometimes, but not always, multiple clearly defined
queries and commands work better than a number of various class methods.</li>
</ul>

<h1 id="the-grand-refactoring">The Grand Refactoring</h1>

<p>Letâ€™s take CQRS, mix it with the reactive approach and apply it to the <code>BookService</code>.</p>

<h2 id="api">API</h2>

<p>First of all, we now know that the <code>BookService</code> is not stateless but stateful.
The clear state representation will make the API much more explicit.</p>

<pre><code class="language-kotlin">sealed class State {
    object Progress : State()
    data class Content(val books: List&lt;Book&gt;) : State()
    object Error : State()
}

val state: Observable&lt;State&gt;
</code></pre>

<p>This is a major step on the right course.</p>

<ul>
<li>The <code>getBooks</code> method was removed â€”Â good riddance! It looked like a stateless one
but actually modified state under the hood and provided side effects.</li>
<li><code>getBooksProgress</code> and <code>getBooksFailure</code> properties were removed as well since they were
actually a side effect representation.</li>
<li>There is a clear <code>state</code> property which declares that it is always there
and can be updated thanks to the signature â€”Â it is a property and the <code>Observable</code>.</li>
</ul>

<p>It is clear that the <code>State</code> class represents a CQRS Query. What about Commands?</p>

<pre><code class="language-kotlin">sealed class Command {
    object Refresh : Command()
    data class Create(val book: Book) : Command()
    data class Delete(val book: Book) : Command()
}

val command: Consumer&lt;Command&gt;
</code></pre>

<p>Notice the <code>Refresh</code> command which explicitly declares
the re-fetch action instead of an implicit <code>getBooks</code> behavior.</p>

<p>This is a bit idealistic API though. In the future we might want
to receive a command result outside of the <code>State</code> â€”
which will become handy for error handling.
Potentially it can be solved with a syntax sugar.</p>

<pre><code class="language-kotlin">interface BookService {

    enum class ResultCreate { Success, Failure }
    enum class ResultDelete { Success, Failure }

    val refresh: Action

    fun create(book: Book): Single&lt;ResultCreate&gt;
    fun delete(book: Book): Single&lt;ResultDelete&gt;

    class Impl : BookService {

        private sealed class Command {
            object Refresh : Command()
            data class Create(val book: Book) : Command()
            data class Delete(val book: Book) : Command()
        }
    }
}
</code></pre>

<h2 id="implementation">Implementation</h2>

<p>First of all, weâ€™ll need stateless commands stream and stateful state one.</p>

<ul>
<li>Commands come and go, the <code>BookService</code> reacts to them and moves on.</li>
<li>The State is being preserved during the runtime.</li>
</ul>

<pre><code class="language-kotlin">class Impl(api: BooksApi) : BookService {
    override val state = BehaviorRelay.create&lt;State&gt;().toSerialized()
    override val command = PublishRelay.create&lt;Command&gt;().toSerialized()
}
</code></pre>

<p>Next, we are going to react to commands and produce states based on results.
The refresh command is pretty straightforward.</p>

<pre><code class="language-kotlin">val refreshState = command
    .ofType&lt;Command.Refresh&gt;()
    .map { State.Progress }

val refreshResultState = command
    .ofType&lt;Command.Refresh&gt;()
    .switchMap { api.getBooks() }
    .map {
        when (it) {
            is BooksResponse.Success -&gt; State.Content(it.books)
            is BooksResponse.Failure -&gt; State.Error
        }
    }
</code></pre>

<p>Create and delete commands are a bit more tricky since the implementation depends
on our needs.</p>

<ul>
<li>If we want to refresh books from the backend we can produce <code>Command.Refresh</code> internally.</li>
<li>If we want to combine books locally we can do that by mutating the current state by hand.</li>
</ul>

<p>In this implementation Iâ€™m gonna go with the first one.</p>

<pre><code class="language-kotlin">val createResultCommand = command
    .ofType&lt;Command.Create&gt;()
    .switchMap { api.createBook(it.book) }
    .switchMapSingle {
        when (it) {
            is BookCreateResponse.Success -&gt; Single.just(Command.Refresh)
            is BookCreateResponse.Failure -&gt; Single.never()
        }
    }

val deleteResultCommand = TODO(&quot;Basically the same as the create one.&quot;)
</code></pre>

<p>And now it is time to combine commands and states.</p>

<pre><code class="language-kotlin">disposable += Observable
    .merge(refreshState, refreshResultState)
    .subscribe(state)

disposable += Observable
    .merge(createResultCommand, deleteResultCommand)
    .subscribe(command)
</code></pre>

<p>Done!</p>

<pre><code class="language-kotlin">interface BookService {

    sealed class State {
        object Progress : State()
        data class Content(val books: List&lt;Book&gt;) : State()
        object Error : State()
    }

    sealed class Command {
        object Refresh : Command()
        data class Create(val book: Book) : Command()
        data class Delete(val book: Book) : Command()
    }

    val state: Observable&lt;State&gt;
    val command: Consumer&lt;Command&gt;

    class Impl(disposable: CompositeDisposable, api: BooksApi) : BookService {

        override val state = BehaviorRelay.create&lt;State&gt;().toSerialized()
        override val command = PublishRelay.create&lt;Command&gt;().toSerialized()

        init {
            val refreshState = command
                .ofType&lt;Command.Refresh&gt;()
                .map { State.Progress }

            val refreshResultState = command
                .ofType&lt;Command.Refresh&gt;()
                .switchMap { api.getBooks() }
                .map {
                    when (it) {
                        is BooksResponse.Success -&gt; State.Content(it.books)
                        is BooksResponse.Failure -&gt; State.Error
                    }
                }

            val createResultCommand = command
                .ofType&lt;Command.Create&gt;()
                .switchMap { api.createBook(it.book) }
                .switchMapSingle {
                    when (it) {
                        is BookCreateResponse.Success -&gt; Single.just(Command.Refresh)
                        is BookCreateResponse.Failure -&gt; Single.never()
                    }
                }

            val deleteResultCommand = TODO(&quot;Basically the same as the create one.&quot;)

            disposable += Observable
                .merge(refreshState, refreshResultState)
                .subscribe(state)

            disposable += Observable
                .merge(createResultCommand, deleteResultCommand)
                .subscribe(command)
        }
    }
}
</code></pre>

<h1 id="lessons-learned">Lessons Learned</h1>

<p>CQRS-like reactive APIs for state mutations can be very useful.</p>

<ul>
<li>The API is clear and declarative.</li>
<li>The API forces right concepts (states and state mutations) both on the outside and on the inside.</li>
<li>The API is reactive, directly representing the producer-consumer pair.</li>
<li>The implementation is error-prone-less since the design enforces a single state of truth for both states and state mutations.</li>
<li>The implementation is thread-safe since commands are handled consequentially, one-by-one.</li>
</ul>

<p>It isnâ€™t a silver bullet, but I can definetly suggest it when dealing with the state.</p>

<hr />

<p>Thanks to <a href="https://twitter.com/artem_zin">Artem Zinnatullin</a> for the review!</p>

</main>

</body>

</html>

